import re
import unicodedata
from decimal import Decimal, InvalidOperation

from django.db import transaction, IntegrityError
from rest_framework import serializers
from rest_framework.exceptions import ValidationError

from .models import Client, ClientObjetSocial, SocialObject
from .models import Client, ClientObjetSocial, SocialObject, Associe


CODE_PREFIX = "CL"
CODE_WIDTH = 4  # results in CL0001 style codes


def _next_client_code():
    codes = Client.objects.values_list("code", flat=True)
    max_num = 0
    for c in codes:
        if not c:
            continue
        m = re.search(r"(\d+)$", str(c))
        if m:
            try:
                n = int(m.group(1))
            except ValueError:
                continue
            if n > max_num:
                max_num = n
    return f"{CODE_PREFIX}{(max_num + 1):0{CODE_WIDTH}d}"


# ---------- Normalizers & mappings ----------
def _clean_token(v: str) -> str:
    if v is None:
        return ""
    s = "".join(" " if unicodedata.category(ch).startswith("Z") else ch for ch in str(v))
    s = s.replace("\u00A0", " ").strip().upper()
    return s

STATUT_MAP = {
    "NC": "NOUVELLE CREATION",
    "NE": "NOUVELLE CREATION",
    "EXNEX": "EXISTANTE NON EXERCANTE",
    "ENX": "EXISTANTE NON EXERCANTE",
    "EX": "EXERCANTE",
}
FORME_MAP = {"SURAL": "SUARL"}

def norm_statut(v: str) -> str:
    s = _clean_token(v)
    return STATUT_MAP.get(s, s)

def norm_forme(v: str) -> str:
    s = _clean_token(v)
    return FORME_MAP.get(s, s)

def norm_person(v: str) -> str:
    return _clean_token(v)

def _norm_decimal_str(v) -> str:
    """
    Accepts '1 000,500', '1000.5', '', None -> '1000.500'.
    """
    s = ("" if v is None else str(v)).replace("\u00A0", " ").strip()
    s = s.replace(" ", "").replace(",", ".")
    if s == "":
        s = "0"
    try:
        d = Decimal(s)
    except (InvalidOperation, ValueError):
        raise ValidationError({"detail": f"Nombre invalide: {v!r}"})
    return f"{d:.3f}"

def _norm_int(v) -> int:
    s = ("" if v is None else str(v)).replace(",", ".").strip()
    try:
        return int(float(s)) if s else 0
    except Exception:
        return 0


class ClientSerializer(serializers.ModelSerializer):
    # Allow null so CSV import can autocode
    code = serializers.CharField(required=False, allow_blank=True, allow_null=True)
    statut = serializers.CharField(required=False, allow_blank=True)
    forme_juridique = serializers.CharField(required=False, allow_blank=True)
    type_personne = serializers.CharField(required=True, allow_blank=False)

    # Override numeric-ish fields as CharField so we can normalize ourselves
    capital_social = serializers.CharField(required=False, allow_blank=True)
    valeur_nominale = serializers.CharField(required=False, allow_blank=True)
    nombre_part = serializers.CharField(required=False, allow_blank=True)

    class Meta:
        model = Client
        fields = "__all__"
        extra_kwargs = {"code": {"required": False}}

    def validate(self, attrs):
        # Normalize tokens
        if "statut" in attrs:
            attrs["statut"] = norm_statut(attrs["statut"])
        if "forme_juridique" in attrs:
            attrs["forme_juridique"] = norm_forme(attrs["forme_juridique"])
        if "type_personne" in attrs:
            attrs["type_personne"] = norm_person(attrs["type_personne"])

        # Normalize numbers from flexible CSV / UI inputs
        if "capital_social" in attrs:
            attrs["capital_social"] = _norm_decimal_str(attrs["capital_social"])
        if "valeur_nominale" in attrs:
            attrs["valeur_nominale"] = _norm_decimal_str(attrs["valeur_nominale"])
        if "nombre_part" in attrs:
            attrs["nombre_part"] = _norm_int(attrs["nombre_part"])

        # Allowed values (fallback if model has no choices)
        statut_allowed = {c[0] for c in getattr(Client, "STATUT_CHOICES", [])} or {
            "NOUVELLE CREATION", "EXISTANTE NON EXERCANTE", "EXERCANTE"
        }
        forme_allowed = {c[0] for c in getattr(Client, "FORME_JURIDIQUE_CHOICES", [])} or {
            "SUARL", "SARL", "SA", "PP", "ASSOCIATION"
        }
        person_allowed = {c[0] for c in getattr(Client, "PERSON_TYPE_CHOICES", [])} if hasattr(Client, "PERSON_TYPE_CHOICES") else {
            "PP", "PM", "AS"
        }

        if attrs.get("statut") and attrs["statut"] not in statut_allowed:
            raise serializers.ValidationError({"statut": f"« {attrs['statut']} » n'est pas un choix valide."})
        if attrs.get("forme_juridique") and attrs["forme_juridique"] not in forme_allowed:
            raise serializers.ValidationError({"forme_juridique": f"« {attrs['forme_juridique']} » n'est pas un choix valide."})
        if attrs.get("type_personne") and attrs["type_personne"] not in person_allowed:
            raise serializers.ValidationError({"type_personne": f"« {attrs['type_personne']} » n'est pas un choix valide."})
        return attrs

    def validate_code(self, value):
        if value in (None, ""):
            return value
        v = str(value).strip().upper()
        if self.instance is None:
            if Client.objects.filter(code=v).exists():
                raise ValidationError("Ce code existe déjà.")
        return v

    def create(self, validated_data):
        code = validated_data.get("code")
        if code:
            code = str(code).strip().upper()
            validated_data["code"] = code
            if Client.objects.filter(code=code).exists():
                raise ValidationError({"code": ["Ce code existe déjà."]})

        if not validated_data.get("code"):
            for _ in range(5):
                candidate = _next_client_code()
                validated_data["code"] = candidate
                try:
                    with transaction.atomic():
                        return super().create(validated_data)
                except IntegrityError as e:
                    if "exploitation_client.code" in str(e) or "UNIQUE constraint" in str(e):
                        continue
                    raise
            raise ValidationError({"code": ["Impossible de générer un code unique. Réessayez."]})
        else:
            with transaction.atomic():
                return super().create(validated_data)

    def update(self, instance, validated_data):
        if "code" in validated_data:
            new_code = validated_data.get("code")
            if new_code not in (None, "", instance.code):
                raise ValidationError({"code": ["Le code est immuable et ne peut pas être modifié."]})
            validated_data.pop("code", None)
        return super().update(instance, validated_data)


class ClientObjetSocialSerializer(serializers.ModelSerializer):
    class Meta:
        model = ClientObjetSocial
        fields = "__all__"
        read_only_fields = ("client",)


class SocialObjectSerializer(serializers.ModelSerializer):
    class Meta:
        model = SocialObject
        fields = "__all__"


class AssocieSerializer(serializers.ModelSerializer):
    class Meta:
        model = Associe
        fields = "__all__"
        read_only_fields = ("client", "created_at", "updated_at")

    # Small normalizers for booleans / blank strings
    def to_internal_value(self, data):
        d = super().to_internal_value(data)
        # nothing special; DRF handles dates and email
        return d
