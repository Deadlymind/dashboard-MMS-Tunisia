import re
from django.db import transaction, IntegrityError
from rest_framework.exceptions import ValidationError
from rest_framework import serializers
from .models import Client, ClientObjetSocial, SocialObject
import unicodedata

CODE_PREFIX = "CL"
CODE_WIDTH = 4  # results in CL0001 style codes

def _next_client_code():
    """
    Generate the next unique client code 'CL####' by scanning existing codes.
    Robust against gaps/deletions.
    """
    from .models import Client  # local import to avoid circulars
    codes = Client.objects.values_list("code", flat=True)
    max_num = 0
    for c in codes:
        if not c:
            continue
        m = re.search(r"(\d+)$", str(c))
        if m:
            try:
                n = int(m.group(1))
            except ValueError:
                continue
            if n > max_num:
                max_num = n
    return f"{CODE_PREFIX}{(max_num + 1):0{CODE_WIDTH}d}"


# ---------- Normalizers & mappings ----------
def _clean_token(v: str) -> str:
    if v is None:
        return ""
    # Convert any Unicode Z* space to normal space, strip, uppercase
    s = "".join(" " if unicodedata.category(ch).startswith("Z") else ch for ch in str(v))
    s = s.replace("\u00A0", " ").strip().upper()  # NBSP safety
    return s

STATUT_MAP = {
    "NC": "NOUVELLE CREATION",
    "NE": "NOUVELLE CREATION",
    "EXNEX": "EXISTANTE NON EXERCANTE",
    "ENX": "EXISTANTE NON EXERCANTE",
    "EX": "EXERCANTE",
}
FORME_MAP = {"SURAL": "SUARL"}

def norm_statut(v: str) -> str:
    s = _clean_token(v)
    return STATUT_MAP.get(s, s)

def norm_forme(v: str) -> str:
    s = _clean_token(v)
    return FORME_MAP.get(s, s)

def norm_person(v: str) -> str:
    return _clean_token(v)

# ---------- Serializers ----------
class ClientSerializer(serializers.ModelSerializer):
    # Override fields to bypass model 'choices' validation (we validate ourselves)
    code = serializers.CharField(required=False, allow_blank=True)
    statut = serializers.CharField(required=False, allow_blank=True)
    forme_juridique = serializers.CharField(required=False, allow_blank=True)
    type_personne = serializers.CharField(required=True, allow_blank=False)

    class Meta:
        model = Client
        fields = "__all__"
        extra_kwargs = {"code": {"required": False}}

    def validate(self, attrs):
        # Normalize incoming tokens
        if "statut" in attrs:
            attrs["statut"] = norm_statut(attrs["statut"])
        if "forme_juridique" in attrs:
            attrs["forme_juridique"] = norm_forme(attrs["forme_juridique"])
        if "type_personne" in attrs:
            attrs["type_personne"] = norm_person(attrs["type_personne"])

        # Allowed values (from model choices or sane defaults)
        statut_allowed = {c[0] for c in getattr(Client, "STATUT_CHOICES", [])} or {
            "NOUVELLE CREATION", "EXISTANTE NON EXERCANTE", "EXERCANTE"
        }
        forme_allowed = {c[0] for c in getattr(Client, "FORME_JURIDIQUE_CHOICES", [])} or {
            "SUARL", "SARL", "SA", "PP", "ASSOCIATION"
        }
        person_allowed = {c[0] for c in getattr(Client, "PERSON_TYPE_CHOICES", [])} if hasattr(Client, "PERSON_TYPE_CHOICES") else {
            "PP", "PM", "AS"
        }

        if attrs.get("statut") and attrs["statut"] not in statut_allowed:
            raise serializers.ValidationError({"statut": f"« {attrs['statut']} » n'est pas un choix valide."})
        if attrs.get("forme_juridique") and attrs["forme_juridique"] not in forme_allowed:
            raise serializers.ValidationError({"forme_juridique": f"« {attrs['forme_juridique']} » n'est pas un choix valide."})
        if attrs.get("type_personne") and attrs["type_personne"] not in person_allowed:
            raise serializers.ValidationError({"type_personne": f"« {attrs['type_personne']} » n'est pas un choix valide."})
        return attrs

    def create(self, validated_data):
        """
        - If code is absent: generate a unique one; retry on rare race collisions.
        - If code is present and already used: raise a 400 ValidationError (not 500).
        """
        from .models import Client
        code = validated_data.get("code")
        if code:
            code = str(code).strip().upper()
            validated_data["code"] = code
            if Client.objects.filter(code=code).exists():
                raise ValidationError({"code": ["Ce code existe déjà."]})

        # Auto-generate when not provided, with small retry loop for safety
        if not validated_data.get("code"):
            for _ in range(5):
                candidate = _next_client_code()
                validated_data["code"] = candidate
                try:
                    with transaction.atomic():
                        return super().create(validated_data)
                except IntegrityError as e:
                    # If integrity error is about 'code' uniqueness, try again
                    if "exploitation_client.code" in str(e) or "UNIQUE constraint" in str(e):
                        continue
                    raise
            raise ValidationError({"code": ["Impossible de générer un code unique. Réessayez."]})
        else:
            try:
                with transaction.atomic():
                    return super().create(validated_data)
            except IntegrityError as e:
                if "exploitation_client.code" in str(e) or "UNIQUE constraint" in str(e):
                    raise ValidationError({"code": ["Ce code existe déjà."]})
                raise



    def validate_code(self, value):
        """Normalize & early uniqueness check for human-entered codes."""
        from .models import Client
        if value is None or value == "":
            return value
        v = str(value).strip().upper()
        if Client.objects.filter(code=v).exists():
            raise ValidationError("Ce code existe déjà.")
        return v

class ClientObjetSocialSerializer(serializers.ModelSerializer):
    class Meta:
        model = ClientObjetSocial
        fields = "__all__"
        read_only_fields = ("client",)

class SocialObjectSerializer(serializers.ModelSerializer):
    class Meta:
        model = SocialObject
        fields = "__all__"
