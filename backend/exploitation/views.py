# backend/exploitation/views.py
from rest_framework import viewsets, generics, permissions
from rest_framework.decorators import api_view, permission_classes, action
from rest_framework.response import Response
from rest_framework.parsers import MultiPartParser, FormParser, JSONParser
from rest_framework.renderers import BaseRenderer, JSONRenderer, BrowsableAPIRenderer
from django.http import HttpResponse

import csv
import io

from .models import Client, ClientObjetSocial, SocialObject
from .serializers import (
    ClientSerializer,
    ClientObjetSocialSerializer,
    SocialObjectSerializer,
)

try:
    import pycountry
except Exception:
    pycountry = None


# --- Minimal CSV renderer to satisfy DRF content negotiation for Accept: text/csv ---
class PassthroughCSVRenderer(BaseRenderer):
    media_type = "text/csv"
    format = "csv"
    charset = "utf-8"
    render_style = "binary"

    def render(self, data, accepted_media_type=None, renderer_context=None):
        # We return HttpResponse for export, so this is rarely used;
        # it's here so DRF accepts `Accept: text/csv`.
        if data is None:
            return b""
        if isinstance(data, (bytes, bytearray)):
            return bytes(data)
        if isinstance(data, str):
            return data.encode(self.charset, errors="replace")
        return str(data).encode(self.charset, errors="replace")


# --- Clients ---
class ClientViewSet(viewsets.ModelViewSet):
    queryset = Client.objects.all().order_by("id")
    serializer_class = ClientSerializer
    permission_classes = [permissions.AllowAny]  # DEV only; tighten later
    parser_classes = [MultiPartParser, FormParser, JSONParser]  # needed for CSV uploads

    def get_queryset(self):
        qs = super().get_queryset()
        q = (self.request.query_params.get("q") or self.request.query_params.get("search") or "").strip()
        if q:
            from django.db.models import Q
            qs = qs.filter(
                Q(code__icontains=q)
                | Q(raison_sociale__icontains=q)
                | Q(denomination_commerciale__icontains=q)
                | Q(matricule_fiscal__icontains=q)
                | Q(identifiant_unique__icontains=q)
            )
        return qs

    @action(
        detail=False,
        methods=["get"],
        url_path="export",
        renderer_classes=[PassthroughCSVRenderer, JSONRenderer, BrowsableAPIRenderer],
    )
    def export_csv(self, request):
        """
        Export filtered clients as CSV.
        Respects filters (?q=...). Not limited by pagination.
        Produces Excel-friendly UTF-8 BOM + CRLF line endings.
        """
        qs = self.filter_queryset(self.get_queryset())

        fields = [
            "code",
            "raison_sociale",
            "type_personne",
            "statut",
            "forme_juridique",
            "pays",
            "ville",
            "assujetti_tva",
            "domicilie_sms",
            "capital_social",
            "valeur_nominale",
            "nombre_part",
            "created_at",
        ]

        buf = io.StringIO(newline="")        # ensure csv uses \r\n
        buf.write("\ufeff")                  # UTF-8 BOM for Excel
        writer = csv.writer(buf)             # default lineterminator is \r\n
        writer.writerow(fields)
        for c in qs:
            row = []
            for f in fields:
                v = getattr(c, f)
                if isinstance(v, bool):
                    v = "1" if v else "0"
                row.append(v)
            writer.writerow(row)

        val = buf.getvalue()
        if not val.endswith("\r\n"):
            val += "\r\n"

        resp = HttpResponse(val, content_type="text/csv; charset=utf-8")
        resp["Content-Disposition"] = 'attachment; filename="clients.csv"'
        return resp

    @action(detail=False, methods=["post"], url_path="import")
    def import_csv(self, request):
        """
        Import clients from a CSV file uploaded as `file`.

        Expected headers:
          code,raison_sociale,type_personne,statut,forme_juridique,pays,ville,
          assujetti_tva,domicilie_sms,capital_social,valeur_nominale,nombre_part

        Behavior:
          • We ALWAYS ignore the CSV 'code' and auto-generate a new one,
            EXCEPT when you pass ?duplicate=update AND an existing code is found:
            in that case we update the existing record WITHOUT changing its code.
          • ?duplicate values still accepted:
              - duplicate=update : update existing matching code (code unchanged)
              - duplicate=skip   : ignored (since we autocode for creates)
              - duplicate=error  : ignored (since we autocode for creates)
              - duplicate=autocode (default): creates with fresh codes
        """
        upload = request.FILES.get("file")
        if not upload:
            return Response({"file": ["Ce champ est obligatoire."]}, status=400)

        # Helpers for robust parsing
        def clean_bool(v):
            return str(v or "").strip().lower() in {"1", "true", "yes", "y", "oui"}

        def clean_dec(v):
            s = str(v or "").strip()
            s = s.replace("\u00A0", " ").replace(" ", "").replace(",", ".")  # normalize spaces/comma
            return s or "0"

        def clean_int(v):
            s = str(v or "").strip().replace(",", ".")
            try:
                return int(float(s))
            except Exception:
                return 0

        # Ensure we read text from the binary file handle
        try:
            upload.seek(0)
        except Exception:
            pass
        text = io.TextIOWrapper(getattr(upload, "file", upload), encoding="utf-8", errors="replace", newline="")
        reader = csv.DictReader(text)

        # Strip BOM from header names so 'code' is recognized (first column may be '\ufeffcode')
        if reader.fieldnames:
            reader.fieldnames = [
                (name.lstrip("\ufeff") if isinstance(name, str) else name)
                for name in reader.fieldnames
            ]

        duplicate = (request.query_params.get("duplicate") or "autocode").lower().strip()
        if duplicate not in {"error", "autocode", "skip", "update"}:
            duplicate = "autocode"

        created, updated, skipped, errors = [], [], 0, []

        for i, row in enumerate(reader, start=2):  # 1 = header
            # Also sanitize any BOM on per-row keys
            row = {
                (k.lstrip("\ufeff") if isinstance(k, str) else k): v
                for k, v in row.items()
            }

            code_raw = (row.get("code") or "").strip()
            # Fallback for missing raison_sociale
            raison = (row.get("raison_sociale") or "").strip()
            if not raison:
                raison = code_raw or f"Client {i}"

            payload = {
                # NOTE: we will force code=None for creates (autocode)
                "code": code_raw or None,
                "raison_sociale": raison,
                "type_personne": (row.get("type_personne") or "PM").strip(),
                "statut": (row.get("statut") or "").strip(),
                "forme_juridique": (row.get("forme_juridique") or "").strip(),
                "pays": (row.get("pays") or "TN").strip(),
                "ville": (row.get("ville") or "").strip(),
                "assujetti_tva": clean_bool(row.get("assujetti_tva")),
                "domicilie_sms": clean_bool(row.get("domicilie_sms")),
                "capital_social": clean_dec(row.get("capital_social")),
                "valeur_nominale": clean_dec(row.get("valeur_nominale")),
                "nombre_part": clean_int(row.get("nombre_part")),
            }

            # --- UPDATE path (only case where we use CSV code) ---
            if duplicate == "update" and code_raw:
                code_norm = code_raw.upper()
                try:
                    instance = Client.objects.get(code=code_norm)
                except Client.DoesNotExist:
                    instance = None

                if instance:
                    # Do not allow changing the code on update
                    payload.pop("code", None)
                    ser = self.get_serializer(instance, data=payload, partial=True)
                    if ser.is_valid():
                        try:
                            ser.save()
                            updated.append(instance.id)
                        except Exception as e:
                            errors.append({"row": i, "errors": {"non_field_errors": [str(e)]}})
                    else:
                        errors.append({"row": i, "errors": ser.errors})
                    continue  # handled update; go next row

            # --- CREATE path: always autocode (ignore CSV code) ---
            payload["code"] = None  # force new auto-generated code
            ser = self.get_serializer(data=payload)
            if ser.is_valid():
                try:
                    obj = ser.save()
                    created.append(obj.id)
                except Exception as e:
                    errors.append({"row": i, "errors": {"non_field_errors": [str(e)]}})
            else:
                errors.append({"row": i, "errors": ser.errors})

        return Response({"created": created, "updated": updated, "skipped": skipped, "errors": errors})


@api_view(["GET"])
@permission_classes([permissions.AllowAny])
def client_choices(request):
    person_types = [["PP", "Personne Physique"], ["PM", "Personne Morale"], ["AS", "Association"]]
    statuts = [
        ["NOUVELLE CREATION", "Nouvelle création"],
        ["EXISTANTE NON EXERCANTE", "Existante non exerçante"],
        ["EXERCANTE", "Exerçante"],
    ]
    formes_juridiques = [
        ["SUARL", "SUARL"],
        ["SURAL", "SURAL"],
        ["SARL", "SARL"],
        ["SA", "SA"],
        ["PP", "PP"],
        ["ASSOCIATION", "ASSOCIATION"],
    ]
    countries = (
        [{"code": getattr(c, "alpha_2", ""), "name": getattr(c, "name", "")} for c in getattr(pycountry, "countries", [])]
        if pycountry and getattr(pycountry, "countries", None)
        else [{"code": "TN", "name": "Tunisia"}, {"code": "FR", "name": "France"}, {"code": "IT", "name": "Italy"}]
    )
    return Response(
        {"person_types": person_types, "statuts": statuts, "formes_juridiques": formes_juridiques, "countries": countries}
    )


class SocialObjectViewSet(viewsets.ModelViewSet):
    queryset = SocialObject.objects.all().order_by("id")
    serializer_class = SocialObjectSerializer
    permission_classes = [permissions.AllowAny]


# --- Client <-> Objet social assignment ---
class ClientObjetSocialListCreate(generics.ListCreateAPIView):
    permission_classes = [permissions.AllowAny]
    serializer_class = ClientObjetSocialSerializer
    pagination_class = None  # ensure a plain list (no 'results' wrapper)

    def get_queryset(self):
        client_id = self.kwargs.get("client_id")
        return ClientObjetSocial.objects.filter(client_id=client_id).order_by("id")

    def perform_create(self, serializer):
        serializer.save(client_id=self.kwargs.get("client_id"))


class ClientObjetSocialDestroy(generics.DestroyAPIView):
    permission_classes = [permissions.AllowAny]
    serializer_class = ClientObjetSocialSerializer

    def get_queryset(self):
        client_id = self.kwargs.get("client_id")
        return ClientObjetSocial.objects.filter(client_id=client_id)
